/** Copyright (c) 2017 Samsung Electronics Co., Ltd.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
// This File has been auto-generated by SWIG and then modified using DALi Ruby Scripts
//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.9
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace NUI {

    using System;
    using System.Runtime.InteropServices;

    
public class View : CustomActor {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;

  internal View(global::System.IntPtr cPtr, bool cMemoryOwn) : base(NDalicPINVOKE.View_SWIGUpcast(cPtr), cMemoryOwn) {
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(View obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~View() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NDalicPINVOKE.delete_View(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }



    private EventHandler _keyInputFocusGainedEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void KeyInputFocusGainedCallbackType(IntPtr control);
    private KeyInputFocusGainedCallbackType _keyInputFocusGainedCallback;

    /**
     * @brief Event for KeyInputFocusGained signal which can be used to subscribe/unsubscribe the event handler
     * provided by the user. KeyInputFocusGained signal is emitted when the control gets Key Input Focus.
     */
    public event EventHandler KeyInputFocusGained
    {
      add
      {
        if (_keyInputFocusGainedEventHandler == null)
        {
          _keyInputFocusGainedCallback = OnKeyInputFocusGained;
          this.KeyInputFocusGainedSignal().Connect(_keyInputFocusGainedCallback);
        }

        _keyInputFocusGainedEventHandler += value;
      }

      remove
      {
        if (_keyInputFocusGainedEventHandler != null)
        {
          this.KeyInputFocusGainedSignal().Disconnect(_keyInputFocusGainedCallback);
        }

        _keyInputFocusGainedEventHandler -= value;
      }
    }

    private void OnKeyInputFocusGained(IntPtr view)
    {
      if (_keyInputFocusGainedEventHandler != null)
      {
        _keyInputFocusGainedEventHandler(this, null);
      }
    }


    private EventHandler _keyInputFocusLostEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void KeyInputFocusLostCallbackType(IntPtr control);
    private KeyInputFocusLostCallbackType _keyInputFocusLostCallback;

    /**
     * @brief Event for KeyInputFocusLost signal which can be used to subscribe/unsubscribe the event handler
     * provided by the user. KeyInputFocusLost signal is emitted when the control loses Key Input Focus.
     */
    public event EventHandler KeyInputFocusLost
    {
      add
      {
          if (_keyInputFocusLostEventHandler == null)
          {
            _keyInputFocusLostCallback = OnKeyInputFocusLost;
            this.KeyInputFocusLostSignal().Connect(_keyInputFocusLostCallback);
          }

        _keyInputFocusLostEventHandler += value;
      }

      remove
      {
          if (_keyInputFocusLostEventHandler != null)
          {
            this.KeyInputFocusLostSignal().Disconnect(_keyInputFocusLostCallback);
          }

          _keyInputFocusLostEventHandler -= value;
      }
    }

    private void OnKeyInputFocusLost(IntPtr view)
    {
      if (_keyInputFocusLostEventHandler != null)
      {
        _keyInputFocusLostEventHandler(this, null);
      }
    }


    /**
     * @brief Event arguments that passed via KeyEvent signal
     *
     */
    public class KeyEventArgs : EventArgs
    {
      private KeyEvent _keyEvent;

      /**
       * @brief KeyEvent - is the keyevent sent to the View.
       *
       */
      public KeyEvent KeyEvent
      {
        get
        {
          return _keyEvent;
        }
        set
        {
          _keyEvent = value;
        }
      }
    }

    private EventHandlerWithReturnType<object,KeyEventArgs,bool> _keyEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate bool KeyCallbackType(IntPtr control, IntPtr keyEvent);
    private KeyCallbackType _keyCallback;

    /**
     * @brief Event for KeyPressed signal which can be used to subscribe/unsubscribe the event handler
     * provided by the user. KeyPressed signal is emitted when key event is received.
     */
    public event EventHandlerWithReturnType<object,KeyEventArgs,bool> KeyPressed
    {
      add
      {
        if (_keyEventHandler == null)
        {
          _keyCallback = OnKeyEvent;
          this.KeyEventSignal().Connect(_keyCallback);
        }

        _keyEventHandler += value;
      }

      remove
      {
        if (_keyEventHandler != null)
        {
          this.KeyEventSignal().Disconnect(_keyCallback);
        }

        _keyEventHandler -= value;
      }
    }

    private bool OnKeyEvent(IntPtr view, IntPtr keyEvent)
    {
      KeyEventArgs e = new KeyEventArgs();

      e.KeyEvent = NUI.KeyEvent.GetKeyEventFromPtr(keyEvent);

      if (_keyEventHandler != null)
      {
        return _keyEventHandler(this, e);
      }
      return false;
    }


    private EventHandler _onRelayoutEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void OnRelayoutEventCallbackType(IntPtr control);
    private OnRelayoutEventCallbackType _onRelayoutEventCallback;

    /**
      * @brief Event for OnRelayout signal which can be used to subscribe/unsubscribe the event handler
      * OnRelayout signal is emitted after the size has been set on the view during relayout.
      */
    public event EventHandler OnRelayoutEvent
    {
      add
      {
        if (_onRelayoutEventHandler == null)
        {
          _onRelayoutEventCallback = OnRelayout;
          this.OnRelayoutSignal().Connect(_onRelayoutEventCallback);
        }

        _onRelayoutEventHandler += value;
      }

      remove
      {
        if (_onRelayoutEventHandler != null)
        {
          this.OnRelayoutSignal().Disconnect(_onRelayoutEventCallback);
        }

        _onRelayoutEventHandler -= value;
      }
    }

    // Callback for View OnRelayout signal
    private void OnRelayout(IntPtr data)
    {
      if (_onRelayoutEventHandler != null)
      {
        _onRelayoutEventHandler(this, null);
      }
    }


    /**
      * @brief Event arguments that passed via Touch signal
      *
      */
    public class TouchEventArgs : EventArgs
    {
       private TouchData _touchData;

      /**
        * @brief TouchData - contains the information of touch points
        *
        */
      public TouchData TouchData
      {
        get
        {
          return _touchData;
        }
        set
        {
          _touchData = value;
        }
      }
    }

    private EventHandlerWithReturnType<object,TouchEventArgs,bool> _touchDataEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate bool TouchDataCallbackType(IntPtr view, IntPtr touchData);
    private TouchDataCallbackType _touchDataCallback;

    /**
      * @brief Event for Touched signal which can be used to subscribe/unsubscribe the event handler
      * provided by the user. Touched signal is emitted when touch input is received.
      */
    public event EventHandlerWithReturnType<object,TouchEventArgs,bool> Touched
    {
      add
      {
        if (_touchDataEventHandler == null)
        {
          _touchDataCallback = OnTouch;
          this.TouchSignal().Connect(_touchDataCallback);
        }

        _touchDataEventHandler += value;
      }

      remove
      {
        if (_touchDataEventHandler != null)
        {
          this.TouchSignal().Disconnect(_touchDataCallback);
        }

        _touchDataEventHandler -= value;
      }
    }

    // Callback for View TouchSignal
    private bool OnTouch(IntPtr view, IntPtr touchData)
    {
      TouchEventArgs e = new TouchEventArgs();

      e.TouchData = NUI.TouchData.GetTouchDataFromPtr(touchData);

      if (_touchDataEventHandler != null)
      {
        return _touchDataEventHandler(this, e);
      }
      return false;
    }


    /**
      * @brief Event arguments that passed via Hover signal
      *
      */
    public class HoverEventArgs : EventArgs
    {
      private HoverEvent _hoverEvent;
      /**
        * @brief HoverEvent - contains touch points that represent the points
        * that are currently being hovered or the points where a hover has stopped
        *
        */
      public HoverEvent HoverEvent
      {
        get
        {
          return _hoverEvent;
        }
        set
        {
          _hoverEvent = value;
        }
      }
    }

    private EventHandlerWithReturnType<object,HoverEventArgs,bool> _hoverEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate bool HoverEventCallbackType(IntPtr view, IntPtr hoverEvent);
    private HoverEventCallbackType _hoverEventCallback;

    /**
      * @brief Event for Hovered signal which can be used to subscribe/unsubscribe the event handler
      * provided by the user. Hovered signal is emitted when hover input is received.
      */
    public event EventHandlerWithReturnType<object,HoverEventArgs,bool> Hovered
    {
      add
      {
        if (_hoverEventHandler == null)
        {
          _hoverEventCallback = OnHoverEvent;
          this.HoveredSignal().Connect(_hoverEventCallback);
        }

        _hoverEventHandler += value;
      }

      remove
      {
        if (_hoverEventHandler != null)
        {
          this.HoveredSignal().Disconnect(_hoverEventCallback);
        }

        _hoverEventHandler -= value;
      }
    }

    // Callback for View Hover signal
    private bool OnHoverEvent(IntPtr view, IntPtr hoverEvent)
    {
      HoverEventArgs e = new HoverEventArgs();

      e.HoverEvent = NUI.HoverEvent.GetHoverEventFromPtr(hoverEvent);

      if (_hoverEventHandler != null)
      {
        return _hoverEventHandler(this, e);
      }
      return false;
    }


    /**
      * @brief Event arguments that passed via Wheel signal
      *
      */
    public class WheelEventArgs : EventArgs
    {
      private WheelEvent _wheelEvent;
      /**
        * @brief WheelEvent - store a wheel rolling type : MOUSE_WHEEL or CUSTOM_WHEEL
        *
        */
      public WheelEvent WheelEvent
      {
        get
        {
          return _wheelEvent;
        }
        set
        {
          _wheelEvent = value;
        }
      }
    }

    private EventHandlerWithReturnType<object,WheelEventArgs,bool> _wheelEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate bool WheelEventCallbackType(IntPtr view, IntPtr wheelEvent);
    private WheelEventCallbackType _wheelEventCallback;

    /**
      * @brief Event for WheelMoved signal which can be used to subscribe/unsubscribe the event handler
      * provided by the user. WheelMoved signal is emitted when wheel event is received.
      */
    public event EventHandlerWithReturnType<object,WheelEventArgs,bool> WheelMoved
    {
      add
      {
        if (_wheelEventHandler == null)
        {
          _wheelEventCallback = OnWheelEvent;
          this.WheelEventSignal().Connect(_wheelEventCallback);
        }

        _wheelEventHandler += value;
      }

      remove
      {
        if (_wheelEventHandler != null)
        {
          this.WheelEventSignal().Disconnect(_wheelEventCallback);
        }

        _wheelEventHandler -= value;
      }
    }

    // Callback for View Wheel signal
    private bool OnWheelEvent(IntPtr view, IntPtr wheelEvent)
    {
      WheelEventArgs e = new WheelEventArgs();

      e.WheelEvent = NUI.WheelEvent.GetWheelEventFromPtr(wheelEvent);

      if (_wheelEventHandler != null)
      {
        return _wheelEventHandler(this, e);
      }
      return false;
    }


    private EventHandler _onStageEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void OnStageEventCallbackType(IntPtr control);
    private OnStageEventCallbackType _onStageEventCallback;

    /**
      * @brief Event for OnStage signal which can be used to subscribe/unsubscribe the event handler
      * OnStage signal is emitted after the view has been connected to the stage.
      */
    public event EventHandler OnStageEvent
    {
      add
      {
        if (_onStageEventHandler == null)
        {
          _onStageEventCallback = OnStage;
          this.OnStageSignal().Connect(_onStageEventCallback);
        }

        _onStageEventHandler += value;
      }

      remove
      {
        if (_onStageEventHandler != null)
        {
          this.OnStageSignal().Disconnect(_onStageEventCallback);
        }

        _onStageEventHandler -= value;
      }
    }

    // Callback for View OnStage signal
    private void OnStage(IntPtr data)
    {
      if (_onStageEventHandler != null)
      {
        _onStageEventHandler(this, null);
      }
    }


    private EventHandler _offStageEventHandler;
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    private delegate void OffStageEventCallbackType(IntPtr control);
    private OffStageEventCallbackType _offStageEventCallback;

    /**
      * @brief Event for OffStage signal which can be used to subscribe/unsubscribe the event handler
      * OffStage signal is emitted after the view has been disconnected from the stage.
      */
    public event EventHandler OffStageEvent
    {
      add
      {
        if (_offStageEventHandler == null)
        {
          _offStageEventCallback = OffStage;
          this.OnStageSignal().Connect(_offStageEventCallback);
        }

        _offStageEventHandler += value;
      }

      remove
      {
        if (_offStageEventHandler != null)
        {
          this.OnStageSignal().Disconnect(_offStageEventCallback);
        }
        _offStageEventHandler -= value;
      }
    }

    // Callback for View OffStage signal
    private void OffStage(IntPtr data)
    {
      if (_offStageEventHandler != null)
      {
        _offStageEventHandler(this, null);
      }
    }


    public static View GetViewFromPtr(global::System.IntPtr cPtr) {
      View ret = new View(cPtr, false);
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }

    public IntPtr GetPtrfromView()
    {
       return (IntPtr)swigCPtr;
    }

    public View GetChildViewAt(uint index) 
    {
      return View.DownCast( this.GetChildAt(index) );
    }



    
  public class Property : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal Property(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Property obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    ~Property() {
      Dispose();
    }
  
    public virtual void Dispose() {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            NDalicPINVOKE.delete_View_Property(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
        global::System.GC.SuppressFinalize(this);
      }
    }
  
    public Property() : this(NDalicPINVOKE.new_View_Property(), true) {
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    }
  
    public static readonly int STYLE_NAME = NDalicPINVOKE.View_Property_STYLE_NAME_get();
    public static readonly int BACKGROUND_COLOR = NDalicPINVOKE.View_Property_BACKGROUND_COLOR_get();
    public static readonly int BACKGROUND_IMAGE = NDalicPINVOKE.View_Property_BACKGROUND_IMAGE_get();
    public static readonly int KEY_INPUT_FOCUS = NDalicPINVOKE.View_Property_KEY_INPUT_FOCUS_get();
    public static readonly int BACKGROUND = NDalicPINVOKE.View_Property_BACKGROUND_get();
  
  }

  public class KeyboardFocus : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal KeyboardFocus(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(KeyboardFocus obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    ~KeyboardFocus() {
      Dispose();
    }
  
    public virtual void Dispose() {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            NDalicPINVOKE.delete_View_KeyboardFocus(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
        global::System.GC.SuppressFinalize(this);
      }
    }
  
    public KeyboardFocus() : this(NDalicPINVOKE.new_View_KeyboardFocus(), true) {
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    }
  
    public enum Direction {
      LEFT,
      RIGHT,
      UP,
      DOWN,
      PAGE_UP,
      PAGE_DOWN
    }
  
  }

  public View () : this (NDalicPINVOKE.View_New(), true) {
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();

  }
  public View(View uiControl) : this(NDalicPINVOKE.new_View__SWIG_1(View.getCPtr(uiControl)), true) {
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public View Assign(View handle) {
    View ret = new View(NDalicPINVOKE.View_Assign(swigCPtr, View.getCPtr(handle)), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public new static View DownCast(BaseHandle handle) {
    View ret = new View(NDalicPINVOKE.View_DownCast(BaseHandle.getCPtr(handle)), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void SetKeyInputFocus() {
    NDalicPINVOKE.View_SetKeyInputFocus(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public bool HasKeyInputFocus() {
    bool ret = NDalicPINVOKE.View_HasKeyInputFocus(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void ClearKeyInputFocus() {
    NDalicPINVOKE.View_ClearKeyInputFocus(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public PinchGestureDetector GetPinchGestureDetector() {
    PinchGestureDetector ret = new PinchGestureDetector(NDalicPINVOKE.View_GetPinchGestureDetector(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public PanGestureDetector GetPanGestureDetector() {
    PanGestureDetector ret = new PanGestureDetector(NDalicPINVOKE.View_GetPanGestureDetector(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public TapGestureDetector GetTapGestureDetector() {
    TapGestureDetector ret = new TapGestureDetector(NDalicPINVOKE.View_GetTapGestureDetector(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public LongPressGestureDetector GetLongPressGestureDetector() {
    LongPressGestureDetector ret = new LongPressGestureDetector(NDalicPINVOKE.View_GetLongPressGestureDetector(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void SetStyleName(string styleName) {
    NDalicPINVOKE.View_SetStyleName(swigCPtr, styleName);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public string GetStyleName() {
    string ret = NDalicPINVOKE.View_GetStyleName(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void SetBackgroundColor(Vector4 color) {
    NDalicPINVOKE.View_SetBackgroundColor(swigCPtr, Vector4.getCPtr(color));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Vector4 GetBackgroundColor() {
    Vector4 ret = new Vector4(NDalicPINVOKE.View_GetBackgroundColor(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void SetBackgroundImage(Image image) {
    NDalicPINVOKE.View_SetBackgroundImage(swigCPtr, Image.getCPtr(image));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public void ClearBackground() {
    NDalicPINVOKE.View_ClearBackground(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public ControlKeyEventSignal KeyEventSignal() {
    ControlKeyEventSignal ret = new ControlKeyEventSignal(NDalicPINVOKE.View_KeyEventSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public KeyInputFocusSignal KeyInputFocusGainedSignal() {
    KeyInputFocusSignal ret = new KeyInputFocusSignal(NDalicPINVOKE.View_KeyInputFocusGainedSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public KeyInputFocusSignal KeyInputFocusLostSignal() {
    KeyInputFocusSignal ret = new KeyInputFocusSignal(NDalicPINVOKE.View_KeyInputFocusLostSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public View(ViewImpl implementation) : this(NDalicPINVOKE.new_View__SWIG_2(ViewImpl.getCPtr(implementation)), true) {
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public enum PropertyRange {
    PROPERTY_START_INDEX = PropertyRanges.PROPERTY_REGISTRATION_START_INDEX,
    CONTROL_PROPERTY_START_INDEX = PROPERTY_START_INDEX,
    CONTROL_PROPERTY_END_INDEX = CONTROL_PROPERTY_START_INDEX+1000
  }

  public string StyleName
  {
    get
    {
      string temp;
      GetProperty( View.Property.STYLE_NAME).Get( out temp );
      return temp;
    }
    set
    {
      SetProperty( View.Property.STYLE_NAME, new NUI.Property.Value( value ) );
    }
  }
  public Vector4 BackgroundColor
  {
    get
    {
      Vector4 temp = new Vector4(0.0f,0.0f,0.0f,0.0f);
      GetProperty( View.Property.BACKGROUND_COLOR).Get(  temp );
      return temp;
    }
    set
    {
      SetProperty( View.Property.BACKGROUND_COLOR, new NUI.Property.Value( value ) );
    }
  }
  public NUI.Property.Map BackgroundImage
  {
    get
    {
      NUI.Property.Map temp = new NUI.Property.Map();
      GetProperty( View.Property.BACKGROUND_IMAGE).Get(  temp );
      return temp;
    }
    set
    {
      SetProperty( View.Property.BACKGROUND_IMAGE, new NUI.Property.Value( value ) );
    }
  }
  public bool KeyInputFocus
  {
    get
    {
      bool temp = false;
      GetProperty( View.Property.KEY_INPUT_FOCUS).Get( ref temp );
      return temp;
    }
    set
    {
      SetProperty( View.Property.KEY_INPUT_FOCUS, new NUI.Property.Value( value ) );
    }
  }
  public NUI.Property.Map Background
  {
    get
    {
      NUI.Property.Map temp = new NUI.Property.Map();
      GetProperty( View.Property.BACKGROUND).Get(  temp );
      return temp;
    }
    set
    {
      SetProperty( View.Property.BACKGROUND, new NUI.Property.Value( value ) );
    }
  }

  public Vector2 CellIndex
  {
    get
    {
      Vector2 temp = new Vector2(0.0f,0.0f);
      GetProperty( TableView.ChildProperty.CELL_INDEX).Get(  temp );
      return temp;
    }
    set
    {
      SetProperty( TableView.ChildProperty.CELL_INDEX, new NUI.Property.Value( value ) );
    }
  }
  public float RowSpan
  {
    get
    {
      float temp = 0.0f;
      GetProperty( TableView.ChildProperty.ROW_SPAN).Get( ref temp );
      return temp;
    }
    set
    {
      SetProperty( TableView.ChildProperty.ROW_SPAN, new NUI.Property.Value( value ) );
    }
  }
  public float ColumnSpan
  {
    get
    {
      float temp = 0.0f;
      GetProperty( TableView.ChildProperty.COLUMN_SPAN).Get( ref temp );
      return temp;
    }
    set
    {
      SetProperty( TableView.ChildProperty.COLUMN_SPAN, new NUI.Property.Value( value ) );
    }
  }
  public string CellHorizontalAlignment
  {
    get
    {
      string temp;
      GetProperty( TableView.ChildProperty.CELL_HORIZONTAL_ALIGNMENT).Get( out temp );
      return temp;
    }
    set
    {
      SetProperty( TableView.ChildProperty.CELL_HORIZONTAL_ALIGNMENT, new NUI.Property.Value( value ) );
    }
  }
  public string CellVerticalAlignment
  {
    get
    {
      string temp;
      GetProperty( TableView.ChildProperty.CELL_VERTICAL_ALIGNMENT).Get( out temp );
      return temp;
    }
    set
    {
      SetProperty( TableView.ChildProperty.CELL_VERTICAL_ALIGNMENT, new NUI.Property.Value( value ) );
    }
  }

  public float Flex
  {
    get
    {
      float temp = 0.0f;
      GetProperty( FlexContainer.ChildProperty.FLEX).Get( ref temp );
      return temp;
    }
    set
    {
      SetProperty( FlexContainer.ChildProperty.FLEX, new NUI.Property.Value( value ) );
    }
  }
  public int AlignSelf
  {
    get
    {
      int temp = 0;
      GetProperty( FlexContainer.ChildProperty.ALIGN_SELF).Get( ref temp );
      return temp;
    }
    set
    {
      SetProperty( FlexContainer.ChildProperty.ALIGN_SELF, new NUI.Property.Value( value ) );
    }
  }
  public Vector4 FlexMargin
  {
    get
    {
      Vector4 temp = new Vector4(0.0f,0.0f,0.0f,0.0f);
      GetProperty( FlexContainer.ChildProperty.FLEX_MARGIN).Get(  temp );
      return temp;
    }
    set
    {
      SetProperty( FlexContainer.ChildProperty.FLEX_MARGIN, new NUI.Property.Value( value ) );
    }
  }

}

}
