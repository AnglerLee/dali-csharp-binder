//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.9
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace NUI {

using System;
using System.Runtime.InteropServices;


public class Stage : BaseHandle {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;

  internal Stage(global::System.IntPtr cPtr, bool cMemoryOwn) : base(NDalicPINVOKE.Stage_SWIGUpcast(cPtr), cMemoryOwn) {
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Stage obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~Stage() {
    DisposeQueue.Instance.Add(this);
  }

  public override void Dispose() {
    if (!Stage.IsInstalled()) {
      DisposeQueue.Instance.Add(this);
      return;
    }

    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NDalicPINVOKE.delete_Stage(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }




  /**
    * @brief Event arguments that passed via Touch signal
    *
    */
  public class TouchEventArgs : EventArgs
  {
    private TouchData touchData;

    public TouchData TouchData
    {
      get
      {
        return touchData;
      }
      set
      {
        touchData = value;
      }
    }
  }

  private event EventHandler<TouchEventArgs> _stageTouchEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageTouchCallbackType(IntPtr data);
  private StageTouchCallbackType _stageTouchCallback;

  /**
    * @brief Event for TouchEvent signal which can be used to subscribe/unsubscribe the event handler
    * TouchEvent signal is emitted when the screen is touched and when the touch ends
    * (i.e. the down & up touch events only).
    *
    */
  public event EventHandler<TouchEventArgs> TouchEvent
  {
    add
    {
      if (_stageTouchEventHandler == null)
      {
        _stageTouchCallback = OnStageTouch;
        this.TouchSignal().Connect(_stageTouchCallback);
      }

      _stageTouchEventHandler += value;
    }
    remove
    {
      if (_stageTouchEventHandler != null)
      {
        this.TouchSignal().Disconnect(_stageTouchCallback);
      }

      _stageTouchEventHandler -= value;
    }
  }

  private void OnStageTouch(IntPtr data)
  {
    TouchEventArgs e = new TouchEventArgs();

    if (data != null)
    {
      e.TouchData = NUI.TouchData.GetTouchDataFromPtr(data);
    }

    if (_stageTouchEventHandler != null)
    {
      _stageTouchEventHandler(this, e);
    }
  }

  /**
    * @brief WheelEvent arguments that passed via Wheel signal
    *
    */
  public class WheelEventArgs : EventArgs
  {
    private WheelEvent wheelEvent;

    public WheelEvent WheelEvent
    {
      get
      {
        return wheelEvent;
      }
      set
      {
        wheelEvent = value;
      }
    }
  }

  private event EventHandler<WheelEventArgs> _stageWheelEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageWheelCallbackType(IntPtr data);
  private StageWheelCallbackType _stageWheelCallback;

  /**
    * @brief Event for WheelEvent signal which can be used to subscribe/unsubscribe the event handler
    * WheelEvent signal is emitted is emitted when wheel event is received.
    *
    */
  public event EventHandler<WheelEventArgs> WheelEvent
  {
    add
    {
      if (_stageWheelEventHandler == null)
      {
        _stageWheelCallback = OnStageWheel;
        this.WheelEventSignal().Connect(_stageWheelCallback);
      }

      _stageWheelEventHandler += value;
    }
    remove
    {
      if (_stageWheelEventHandler != null)
      {
        this.WheelEventSignal().Disconnect(_stageWheelCallback);
      }

      _stageWheelEventHandler -= value;
    }
  }

  private void OnStageWheel(IntPtr data)
  {
    WheelEventArgs e = new WheelEventArgs();

    if (data != null)
    {
      e.WheelEvent = NUI.WheelEvent.GetWheelEventFromPtr(data);
    }

    if (_stageWheelEventHandler != null)
    {
      _stageWheelEventHandler(this, e);
    }
  }

  /**
    * @brief Event arguments that passed via KeyEvent signal
    *
    */
  public class KeyEventArgs : EventArgs
  {
    private KeyEvent keyEvent;

    public KeyEvent KeyEvent
    {
      get
      {
        return keyEvent;
      }
      set
      {
        keyEvent = value;
      }
    }
  }

  private event EventHandler<KeyEventArgs> _stageKeyEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageKeyCallbackType(IntPtr data);
  private StageKeyCallbackType _stageKeyCallback;

  public event EventHandler<KeyEventArgs> KeyEvent
  {
    add
    {
      if (_stageKeyEventHandler == null)
      {
        _stageKeyCallback = OnStageKey;
        this.KeyEventSignal().Connect(_stageKeyCallback);
      }

      _stageKeyEventHandler += value;
    }
    remove
    {
      if (_stageKeyEventHandler != null)
      {
        this.KeyEventSignal().Disconnect(_stageKeyCallback);
      }

      _stageKeyEventHandler -= value;
    }
  }

  private void OnStageKey(IntPtr data)
  {
    KeyEventArgs e = new KeyEventArgs();

    if (data != null)
    {
      e.KeyEvent = NUI.KeyEvent.GetKeyEventFromPtr(data);
    }

    if (_stageKeyEventHandler != null)
    {
      _stageKeyEventHandler(this, e);
    }
  }

  private event EventHandler _stageEventProcessingFinishedEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageEventProcessingFinishedEventCallbackType();
  private StageEventProcessingFinishedEventCallbackType _stageEventProcessingFinishedEventCallback;

  /**
    * @brief Event for EventProcessingFinished signal which can be used to subscribe/unsubscribe the event handler
    * provided by the user. EventProcessingFinished signal is emitted just after the event processing is finished.
    *
    */
  public event EventHandler EventProcessingFinished
  {
    add
    {
      if (_stageEventProcessingFinishedEventHandler == null)
      {
        _stageEventProcessingFinishedEventCallback = OnEventProcessingFinished;
        this.EventProcessingFinishedSignal().Connect(_stageEventProcessingFinishedEventCallback);
      }

      _stageEventProcessingFinishedEventHandler += value;
    }
    remove
    {
      if (_stageEventProcessingFinishedEventHandler != null)
      {
        this.EventProcessingFinishedSignal().Disconnect(_stageEventProcessingFinishedEventCallback);
      }

      _stageEventProcessingFinishedEventHandler -= value;
    }
  }

  private void OnEventProcessingFinished()
  {
    if (_stageEventProcessingFinishedEventHandler != null)
    {
      _stageEventProcessingFinishedEventHandler(this, null);
    }
  }

  private event EventHandler _stageContextLostEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageContextLostEventCallbackType();
  private StageContextLostEventCallbackType _stageContextLostEventCallback;

  /**
    * @brief Event for ContextLost signal which can be used to subscribe/unsubscribe the event handler
    * ContextLost signal is emitted when the GL context is lost (Platform specific behaviour).
    *
    */
  public event EventHandler ContextLost
  {
    add
    {
      if (_stageContextLostEventHandler == null)
      {
        _stageContextLostEventCallback = OnContextLost;
        this.ContextLostSignal().Connect(_stageContextLostEventCallback);
      }

      _stageContextLostEventHandler += value;
    }
    remove
    {
      if (_stageContextLostEventHandler != null)
      {
        this.ContextLostSignal().Disconnect(_stageContextLostEventCallback);
      }

      _stageContextLostEventHandler -= value;
    }
  }

  private void OnContextLost()
  {
    if (_stageContextLostEventHandler != null)
    {
      _stageContextLostEventHandler(this, null);
    }
  }

  private event EventHandler _stageContextRegainedEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageContextRegainedEventCallbackType();
  private StageContextRegainedEventCallbackType _stageContextRegainedEventCallback;

  /**
    * @brief Event for ContextRegained signal which can be used to subscribe/unsubscribe the event handler
    * provided by the user. ContextRegained signal is emitted when the GL context is regained (Platform specific
    * behaviour).
    *
    */
  public event EventHandler ContextRegained
  {
    add
    {
      if (_stageContextRegainedEventHandler == null)
      {
        _stageContextRegainedEventCallback = OnContextRegained;
        this.ContextRegainedSignal().Connect(_stageContextRegainedEventCallback);
      }

      _stageContextRegainedEventHandler += value;
    }
    remove
    {
      if (_stageContextRegainedEventHandler != null)
      {
        this.ContextRegainedSignal().Disconnect(_stageContextRegainedEventCallback);
      }

      _stageContextRegainedEventHandler -= value;
    }
  }

  private void OnContextRegained()
  {
    if (_stageContextRegainedEventHandler != null)
    {
      _stageContextRegainedEventHandler(this, null);
    }
  }

  private event EventHandler _stageSceneCreatedEventHandler;
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate void StageSceneCreatedEventCallbackType();
  private StageSceneCreatedEventCallbackType _stageSceneCreatedEventCallback;

  /**
    * @brief Event for SceneCreated signal which can be used to subscribe/unsubscribe the event handler
    * SceneCreated signal is emitted after the initial scene is created.
    *
    */
  public event EventHandler SceneCreated
  {
    add
    {
      if (_stageSceneCreatedEventHandler == null)
      {
        _stageSceneCreatedEventCallback = OnSceneCreated;
        this.SceneCreatedSignal().Connect(_stageSceneCreatedEventCallback);
      }

      _stageSceneCreatedEventHandler += value;
    }
    remove
    {
      if (_stageSceneCreatedEventHandler != null)
      {
        this.SceneCreatedSignal().Disconnect(_stageSceneCreatedEventCallback);
      }

      _stageSceneCreatedEventHandler -= value;
    }
  }

  private void OnSceneCreated()
  {
    if (_stageSceneCreatedEventHandler != null)
    {
      _stageSceneCreatedEventHandler(this, null);
    }
  }


  public Vector2 Size
  {
     get
     {
        Vector2 ret = GetSize();
        return ret;
     }
  }

  public Vector4 BackgroundColor
  {
     set
     {
        SetBackgroundColor(value);
     }
     get
     {
        Vector4 ret = GetBackgroundColor();
        return ret;
     }
   }

  private static readonly Stage instance = Stage.GetCurrent();

  public static Stage Instance
  {
      get
      {
          return instance;
      }
  }

  public Layer GetDefaultLayer()
  {
    return this.GetRootLayer();
  }

  public void AddLayer(Layer layer)
  {
    this.Add( (Actor)layer );
  }

  public void RemoveLayer(Layer layer)
  {
    this.Remove( (Actor)layer );
  }



  public static Vector4 DEFAULT_BACKGROUND_COLOR {
    get {
      global::System.IntPtr cPtr = NDalicPINVOKE.Stage_DEFAULT_BACKGROUND_COLOR_get();
      Vector4 ret = (cPtr == global::System.IntPtr.Zero) ? null : new Vector4(cPtr, false);
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public static Vector4 DEBUG_BACKGROUND_COLOR {
    get {
      global::System.IntPtr cPtr = NDalicPINVOKE.Stage_DEBUG_BACKGROUND_COLOR_get();
      Vector4 ret = (cPtr == global::System.IntPtr.Zero) ? null : new Vector4(cPtr, false);
      if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  public Stage() : this(NDalicPINVOKE.new_Stage__SWIG_0(), true) {
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public static Stage GetCurrent() {
    Stage ret = new Stage(NDalicPINVOKE.Stage_GetCurrent(), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool IsInstalled() {
    bool ret = NDalicPINVOKE.Stage_IsInstalled();
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Stage(Stage handle) : this(NDalicPINVOKE.new_Stage__SWIG_1(Stage.getCPtr(handle)), true) {
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Stage Assign(Stage rhs) {
    Stage ret = new Stage(NDalicPINVOKE.Stage_Assign(swigCPtr, Stage.getCPtr(rhs)), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void Add(Actor actor) {
    NDalicPINVOKE.Stage_Add(swigCPtr, Actor.getCPtr(actor));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public void Remove(Actor actor) {
    NDalicPINVOKE.Stage_Remove(swigCPtr, Actor.getCPtr(actor));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Vector2 GetSize() {
    Vector2 ret = new Vector2(NDalicPINVOKE.Stage_GetSize(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public RenderTaskList GetRenderTaskList() {
    RenderTaskList ret = new RenderTaskList(NDalicPINVOKE.Stage_GetRenderTaskList(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public uint GetLayerCount() {
    uint ret = NDalicPINVOKE.Stage_GetLayerCount(swigCPtr);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Layer GetLayer(uint depth) {
    Layer ret = new Layer(NDalicPINVOKE.Stage_GetLayer(swigCPtr, depth), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Layer GetRootLayer() {
    Layer ret = new Layer(NDalicPINVOKE.Stage_GetRootLayer(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void SetBackgroundColor(Vector4 color) {
    NDalicPINVOKE.Stage_SetBackgroundColor(swigCPtr, Vector4.getCPtr(color));
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public Vector4 GetBackgroundColor() {
    Vector4 ret = new Vector4(NDalicPINVOKE.Stage_GetBackgroundColor(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Vector2 GetDpi() {
    Vector2 ret = new Vector2(NDalicPINVOKE.Stage_GetDpi(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public ObjectRegistry GetObjectRegistry() {
    ObjectRegistry ret = new ObjectRegistry(NDalicPINVOKE.Stage_GetObjectRegistry(swigCPtr), true);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public void KeepRendering(float durationSeconds) {
    NDalicPINVOKE.Stage_KeepRendering(swigCPtr, durationSeconds);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
  }

  public KeyEventSignal KeyEventSignal() {
    KeyEventSignal ret = new KeyEventSignal(NDalicPINVOKE.Stage_KeyEventSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public VoidSignal EventProcessingFinishedSignal() {
    VoidSignal ret = new VoidSignal(NDalicPINVOKE.Stage_EventProcessingFinishedSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public SWIGTYPE_p_Dali__SignalT_void_fDali__TouchEvent_const_RF_t TouchedSignal() {
    SWIGTYPE_p_Dali__SignalT_void_fDali__TouchEvent_const_RF_t ret = new SWIGTYPE_p_Dali__SignalT_void_fDali__TouchEvent_const_RF_t(NDalicPINVOKE.Stage_TouchedSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public TouchSignal TouchSignal() {
    TouchSignal ret = new TouchSignal(NDalicPINVOKE.Stage_TouchSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public StageWheelEventSignal WheelEventSignal() {
    StageWheelEventSignal ret = new StageWheelEventSignal(NDalicPINVOKE.Stage_WheelEventSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public VoidSignal ContextLostSignal() {
    VoidSignal ret = new VoidSignal(NDalicPINVOKE.Stage_ContextLostSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public VoidSignal ContextRegainedSignal() {
    VoidSignal ret = new VoidSignal(NDalicPINVOKE.Stage_ContextRegainedSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public VoidSignal SceneCreatedSignal() {
    VoidSignal ret = new VoidSignal(NDalicPINVOKE.Stage_SceneCreatedSignal(swigCPtr), false);
    if (NDalicPINVOKE.SWIGPendingException.Pending) throw NDalicPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
